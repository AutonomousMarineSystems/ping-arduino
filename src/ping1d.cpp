/*
* ping1d.cpp
* A device API for the Blue Robotics Ping1D echosounder
*
*~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
* THIS IS AN AUTOGENERATED FILE
* DO NOT EDIT
*~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
*
*/

#include "ping1d.h"

Ping1D::Ping1D(Stream& ser, uint32_t baudrate) : _stream ( ser ) {}
  
  PingMessage* Ping1D::read()
  {
    while(_stream.available()) {
        if (_parser.parseByte(_stream.read()) == PingParser::NEW_MESSAGE) {
          handleMessage(&_parser.rxMsg);
          return &_parser.rxMsg;
        }
    }
    return nullptr;
  }
  
  size_t Ping1D::write(uint8_t* data, uint16_t length)
  {
    return _stream.write(data, length);
  }

  bool Ping1D::initialize(uint16_t ping_interval_ms, uint32_t speed_of_sound)
  {
      if(!request(Ping1DNamespace::Device_id)) {
        return false;
      }

      if (!request(Ping1DNamespace::Fw_version)) {
        return false;
      }

      if(!request(Ping1DNamespace::Voltage_5)) {
        return false;
      }

      if (!request(Ping1DNamespace::Pcb_temperature)) {
        //return false;
      }

      // Configure ping interval
      //if (!set_ping_interval(ping_interval_ms) {
        //return false;
      //}
      
      return true;
  }
  
  PingMessage* Ping1D::waitReply(enum Ping1DNamespace::msg_ping1D_id id, uint16_t timeout_ms)
  {
      uint32_t tstart = millis();
      while (millis() < tstart + timeout_ms) {

        PingMessage* pmsg = read();

        if (!pmsg) {
          continue;
        }

        handleMessage(pmsg);

        if (pmsg->message_id() == Ping1DNamespace::Nack) {
          ping_msg_ping1D_nack nack(*pmsg);

          if (nack.nacked_id() == id) {
            return nullptr;
          }
        }

        if (pmsg->message_id() == id) {
          return pmsg;
        }
      }

      //debug("timed out waiting for id %d", id);
      return nullptr;
  }
  
  void Ping1D::handleMessage(PingMessage* pmsg)
  {
    switch (pmsg->message_id()) {
      case Ping1DNamespace::Nack: {
          ping_msg_ping1D_nack nack(*pmsg);
          //debug("got NACK (%d) %s", nack.nacked_id(), nack.nack_msg());
      }
          break;
      case Ping1DNamespace::Distance:
      {
          ping_msg_ping1D_distance m(*pmsg);
          _distance = m.distance();
          _confidence = m.confidence();
      }
          break;
      case Ping1DNamespace::Distance_simple:
      {
          ping_msg_ping1D_distance_simple m(*pmsg);
          _distance = m.distance();
          _confidence = m.confidence();
      }
          break;
      default:
          break;
    }
  }

  // ex ping_msg_ping1D_voltage_5 msg(*pd.request(Ping1DNamespace::Voltage_5));
  PingMessage* Ping1D::request(enum Ping1DNamespace::msg_ping1D_id id, uint16_t timeout_ms = 400)
  {
    ping_msg_ping1D_empty msg;
    msg.set_id(id);
    msg.updateChecksum();
    write(msg.msgData, msg.msgDataLength());
    return waitReply(id, timeout_ms);
  }
  
  // ex auto msg = pd.request<ping_msg_ping1D_voltage_5>();
  template <typename T>
  T* Ping1D::request() {
    T resp; // todo there should be some other (static) way to get the message id?
    static ping_msg_ping1D_empty req;
    req.set_id(resp.message_id());
    req.updateChecksum();
    write(req.msgData, req.msgDataLength());
    return (T*)waitReply(resp.message_id());
  }


    bool Ping1D::get_fw_version(uint8_t* device_type,
                      uint8_t* device_model,
                      uint16_t* fw_version_major,
                      uint16_t* fw_version_minor) {

        if (!request(Ping1DNamespace::Fw_version)) {
            return false;
        }

        if (device_type) *device_type = _device_type;
        if (device_model) *device_model = _device_model;
        if (fw_version_major) *fw_version_major = _fw_version_major;
        if (fw_version_minor) *fw_version_minor = _fw_version_minor;

        return true;
    }

    bool Ping1D::get_device_id(uint8_t* device_id) {

        if (!request(Ping1DNamespace::Device_id)) {
            return false;
        }

        if (device_id) *device_id = _device_id;

        return true;
    }

    bool Ping1D::get_voltage_5(uint16_t* mvolts) {

        if (!request(Ping1DNamespace::Voltage_5)) {
            return false;
        }

        if (mvolts) *mvolts = _mvolts;

        return true;
    }

    bool Ping1D::get_speed_of_sound(uint32_t* speed_of_sound) {

        if (!request(Ping1DNamespace::Speed_of_sound)) {
            return false;
        }

        if (speed_of_sound) *speed_of_sound = _speed_of_sound;

        return true;
    }

    bool Ping1D::get_range(uint32_t* scan_start,
                      uint32_t* scan_length) {

        if (!request(Ping1DNamespace::Range)) {
            return false;
        }

        if (scan_start) *scan_start = _scan_start;
        if (scan_length) *scan_length = _scan_length;

        return true;
    }

    bool Ping1D::get_mode_auto(uint8_t* mode_auto) {

        if (!request(Ping1DNamespace::Mode_auto)) {
            return false;
        }

        if (mode_auto) *mode_auto = _mode_auto;

        return true;
    }

    bool Ping1D::get_ping_rate(uint16_t* ping_rate) {

        if (!request(Ping1DNamespace::Ping_rate)) {
            return false;
        }

        if (ping_rate) *ping_rate = _ping_rate;

        return true;
    }

    bool Ping1D::get_gain_index(uint32_t* gain_index) {

        if (!request(Ping1DNamespace::Gain_index)) {
            return false;
        }

        if (gain_index) *gain_index = _gain_index;

        return true;
    }

    bool Ping1D::get_pulse_usec(uint16_t* pulse_usec) {

        if (!request(Ping1DNamespace::Pulse_usec)) {
            return false;
        }

        if (pulse_usec) *pulse_usec = _pulse_usec;

        return true;
    }

    bool Ping1D::get_general_info(uint16_t* fw_version_major,
                      uint16_t* fw_version_minor,
                      uint16_t* mvolts,
                      uint16_t* ping_rate,
                      uint8_t* gain_index,
                      uint8_t* mode_auto) {

        if (!request(Ping1DNamespace::General_info)) {
            return false;
        }

        if (fw_version_major) *fw_version_major = _fw_version_major;
        if (fw_version_minor) *fw_version_minor = _fw_version_minor;
        if (mvolts) *mvolts = _mvolts;
        if (ping_rate) *ping_rate = _ping_rate;
        if (gain_index) *gain_index = _gain_index;
        if (mode_auto) *mode_auto = _mode_auto;

        return true;
    }

    bool Ping1D::get_distance_simple(uint32_t* distance,
                      uint8_t* confidence) {

        if (!request(Ping1DNamespace::Distance_simple)) {
            return false;
        }

        if (distance) *distance = _distance;
        if (confidence) *confidence = _confidence;

        return true;
    }

    bool Ping1D::get_distance(uint32_t* distance,
                      uint16_t* confidence,
                      uint16_t* pulse_usec,
                      uint32_t* ping_number,
                      uint32_t* scan_start,
                      uint32_t* scan_length,
                      uint32_t* gain_index) {

        if (!request(Ping1DNamespace::Distance)) {
            return false;
        }

        if (distance) *distance = _distance;
        if (confidence) *confidence = _confidence;
        if (pulse_usec) *pulse_usec = _pulse_usec;
        if (ping_number) *ping_number = _ping_number;
        if (scan_start) *scan_start = _scan_start;
        if (scan_length) *scan_length = _scan_length;
        if (gain_index) *gain_index = _gain_index;

        return true;
    }

    bool Ping1D::get_processor_temperature(uint16_t* temp) {

        if (!request(Ping1DNamespace::Processor_temperature)) {
            return false;
        }

        if (temp) *temp = _temp;

        return true;
    }

    bool Ping1D::get_pcb_temperature(uint16_t* temp) {

        if (!request(Ping1DNamespace::Pcb_temperature)) {
            return false;
        }

        if (temp) *temp = _temp;

        return true;
    }

    bool Ping1D::get_ping_enable(uint8_t* enable) {

        if (!request(Ping1DNamespace::Ping_enable)) {
            return false;
        }

        if (enable) *enable = _enable;

        return true;
    }

    bool Ping1D::get_profile(uint32_t* distance,
                      uint16_t* confidence,
                      uint16_t* pulse_usec,
                      uint32_t* ping_number,
                      uint32_t* scan_start,
                      uint32_t* scan_length,
                      uint32_t* gain_index,
                      uint16_t* num_points,
                      uint8_t* data) {

        if (!request(Ping1DNamespace::Profile)) {
            return false;
        }

        if (distance) *distance = _distance;
        if (confidence) *confidence = _confidence;
        if (pulse_usec) *pulse_usec = _pulse_usec;
        if (ping_number) *ping_number = _ping_number;
        if (scan_start) *scan_start = _scan_start;
        if (scan_length) *scan_length = _scan_length;
        if (gain_index) *gain_index = _gain_index;
        if (num_points) *num_points = _num_points;
        if (data) *data = _data;

        return true;
    }

    bool Ping1D::get_protocol_version(uint32_t* protocol_version) {

        if (!request(Ping1DNamespace::Protocol_version)) {
            return false;
        }

        if (protocol_version) *protocol_version = _protocol_version;

        return true;
    }


    bool Ping1D::set_device_id(uint8_t device_id, bool verify) {
        ping_msg_ping1D_set_device_id m;
        m.set_device_id(device_id);
        m.updateChecksum();
        write(m.msgData, m.msgDataLength());
        if (!request(Ping1DNamespace::Device_id)) {
            return false;
        }
        // Read back the data and check that changes have been applied
        if (verify
              && _device_id != device_id
              || false) {
            return false;
        }
        return true; // success
     }

    bool Ping1D::set_range(uint32_t scan_start, uint32_t scan_length, bool verify) {
        ping_msg_ping1D_set_range m;
        m.set_scan_start(scan_start);
        m.set_scan_length(scan_length);
        m.updateChecksum();
        write(m.msgData, m.msgDataLength());
        if (!request(Ping1DNamespace::Range)) {
            return false;
        }
        // Read back the data and check that changes have been applied
        if (verify
              && _scan_start != scan_start
              || _scan_length != scan_length
              || false) {
            return false;
        }
        return true; // success
     }

    bool Ping1D::set_speed_of_sound(uint32_t speed_of_sound, bool verify) {
        ping_msg_ping1D_set_speed_of_sound m;
        m.set_speed_of_sound(speed_of_sound);
        m.updateChecksum();
        write(m.msgData, m.msgDataLength());
        if (!request(Ping1DNamespace::Speed_of_sound)) {
            return false;
        }
        // Read back the data and check that changes have been applied
        if (verify
              && _speed_of_sound != speed_of_sound
              || false) {
            return false;
        }
        return true; // success
     }

    bool Ping1D::set_mode_auto(uint8_t mode_auto, bool verify) {
        ping_msg_ping1D_set_mode_auto m;
        m.set_mode_auto(mode_auto);
        m.updateChecksum();
        write(m.msgData, m.msgDataLength());
        if (!request(Ping1DNamespace::Mode_auto)) {
            return false;
        }
        // Read back the data and check that changes have been applied
        if (verify
              && _mode_auto != mode_auto
              || false) {
            return false;
        }
        return true; // success
     }

    bool Ping1D::set_ping_rate(uint16_t ping_rate, bool verify) {
        ping_msg_ping1D_set_ping_rate m;
        m.set_ping_rate(ping_rate);
        m.updateChecksum();
        write(m.msgData, m.msgDataLength());
        if (!request(Ping1DNamespace::Ping_rate)) {
            return false;
        }
        // Read back the data and check that changes have been applied
        if (verify
              && _ping_rate != ping_rate
              || false) {
            return false;
        }
        return true; // success
     }

    bool Ping1D::set_gain_index(uint8_t gain_index, bool verify) {
        ping_msg_ping1D_set_gain_index m;
        m.set_gain_index(gain_index);
        m.updateChecksum();
        write(m.msgData, m.msgDataLength());
        if (!request(Ping1DNamespace::Gain_index)) {
            return false;
        }
        // Read back the data and check that changes have been applied
        if (verify
              && _gain_index != gain_index
              || false) {
            return false;
        }
        return true; // success
     }

    bool Ping1D::set_ping_enable(uint8_t enable, bool verify) {
        ping_msg_ping1D_set_ping_enable m;
        m.set_enable(enable);
        m.updateChecksum();
        write(m.msgData, m.msgDataLength());
        if (!request(Ping1DNamespace::Ping_enable)) {
            return false;
        }
        // Read back the data and check that changes have been applied
        if (verify
              && _enable != enable
              || false) {
            return false;
        }
        return true; // success
     }

